# -*- coding: utf-8 -*-
"""feature_functions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_BBjt2oP7m-R0Vh99vmQtm3VuXYVVwlH
"""

import pandas as pd
import numpy as np
from scipy import stats
import scipy.optimize
from scipy.optimize import OptimizeWarning
import warnings
import math
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from mpl_finance import candlestick_ohlc
from matplotlib.dates import date2num
from datetime import datetime

#pip install mpl_finance
class holder:
  pass

##Heiken Ashi candles
def heikenashi(prices, periods):
  """
  :param: prices dataframe of OHLC and volume data
  :param: periods periods for which to create candles
  :return: Heiken Ashi OHLC candles
  """
  
  results = holder()
  dict = {} #stores our candles
  
  HAclose = prices[['open', 'high', 'close', 'low']].sum(axis=1)/4
  
  HAopen = HAclose.copy()
  
  HAopen.iloc[0] = HAclose.iloc[0]
  
  HAhigh = HAclose.copy()
  
  HAlow = HAclose.copy()
  
  for i in range(1, len(prices)):
    HAopen.iloc[i] = (HAopen.iloc[i-1] - HAclose.iloc[i-1])/2
    
    HAhigh.iloc[i] = np.array([prices.high.iloc[i], HAopen.iloc[i], HAclose.iloc[i]]).max()
    
    HAlow.iloc[i] = np.array([prices.low.iloc[i], HAopen.iloc[i], HAclose.iloc[i]]).min()
    
    
  df = pd.concat((HAopen, HAhigh, HAlow, HAclose), axis=1)
  
  df.columns = ['open', 'high', 'close', 'low'] #insurance
  
  #df.index = df.index.droplevel(0)
  
  dict[periods[0]] = df
  
  results.candles = dict
  
  return results

##De-trender

def detrender(prices, method='difference'):
  """
  Detrend the curve. Use difference for a completely
  detrended time series. Oscillating about 0.
  Detrending enables us to use Fourier and Sine Fit
  """
  if method == 'difference':
    detrended = prices.close[1:] - prices.close[:-1].values
  elif method == 'linear':
    x = np.arange(0, len(prices))
    y = prices.close.values

    #create linear regression model
    model = LinearRegression()
    model.fit(x.reshape(-1,1), y)

    trend = model.predict(x.reshape(-1,1))
    trend = trend.reshape((len(prices),))

    detrended = prices.close - trend
  else:
    print("Detrending is either by linear or difference")

  return detrended

##Fourier series expansion function
def fourier_series(x,a0,a1,b1,w):
  """
  :param: x hours (independent variable)
  :param: a0 first fourier series coefficient
  :param: a1 second fourier series coefficient
  :param: b1 third fourier series coefficient
  :param: w fourier series frequency
  :return: value of the fourier function
  """
  f = a0 + a1*np.cos(w*x) + b1*np.sin(w*x) ##fourier function

  return f

##Sine series expansion fitting function
def sine_series(x,a0,b1,w):
  """
  :param: x hours (independent variable)
  :param: a0 first sine series coefficient
  :param: b1 second sine series coefficient
  :param: w sine series frequency
  :return: value of the sine series function
  """
  s = a0 + b1*np.sin(w*x) ##sine series function

  return s

##Fourier series coefficient calculator function

def fourier(prices, periods, method='difference'):
  """
  :param: prices OHLC dataframe
  :param: periods List of periods for which to compute
          coefficients (3,7,10....)
  :param: method method by which to detrend data
  :return: dict of dataframes with coefficient for valid
            periods
  """
  results = holder()
  dict = {}

  plot = True

  #compute series coefficients

  detrended = detrender(prices,method)

  for i in range(0, len(periods)):
    coeffs = []

    for j in range(periods[i], len(prices)-periods[i]):
      x = np.arange(0, periods[i])
      y = detrended.iloc[j-periods[i]:j]

      with warnings.catch_warnings():
        warnings.simplefilter("error", OptimizeWarning)

        try:
          res = scipy.optimize.curve_fit(fourier_series, x, y)
        except (RuntimeError, OptimizeWarning):
          res = np.empty((1,4))
          res[0:] = np.NAN

      if plot == True:
        xt = np.linspace(0, periods[i], 100)
        yt = fourier_series(xt, res[0][0], res[0][1], res[0][2], res[0][3])

        plt.plot(x,y)
        plt.plot(xt,yt, 'r')
        plt.show()

      coeffs = np.append(coeffs, res[0], axis=0)
    warnings.filterwarnings('ignore', category=np.VisibleDeprecationWarning)

    coeffs = np.array(coeffs).reshape(((len(coeffs)/4,4)))

    df = pd.DataFrame(coeffs, index=prices.iloc[periods[i]-periods[i]])

    df.columns = ['a0', 'a1', 'b1', 'w']

    df = df.fillna(method='bfill')

    dict[periods[i]] = df

  results.coeffs = dict

  return results

##Sine series coefficient calculator function

def sine(prices, periods, method='difference'):
  """
  :param: prices OHLC dataframe
  :param: periods List of periods for which to compute
          coefficients (3,7,10....)
  :param: method method by which to detrend data
  :return: dict of dataframes with coefficient for valid
            periods
  """
  results = holder()
  dict = {}

  plot = True

  #compute series coefficients

  detrended = detrender(prices,method)

  for i in range(0, len(periods)):
    coeffs = []

    for j in range(periods[i], len(prices)-periods[i]):
      x = np.arange(0, periods[i])
      y = detrended.iloc[j-periods[i]:j]

      with warnings.catch_warnings():
        warnings.simplefilter("error", OptimizeWarning)

        try:
          res = scipy.optimize.curve_fit(sine_series, x, y)
        except (RuntimeError, OptimizeWarning):
          res = np.empty((1,3))
          res[0:] = np.NAN

      if plot == True:
        xt = np.linspace(0, periods[i], 100)
        yt = sine_series(xt, res[0][0], res[0][1], res[0][2])

        plt.plot(x,y)
        plt.plot(xt,yt, 'r')
        plt.show()

      coeffs = np.append(coeffs, res[0], axis=0)
    warnings.filterwarnings('ignore', category=np.VisibleDeprecationWarning)

    coeffs = np.array(coeffs).reshape(((len(coeffs)/3,3)))

    df = pd.DataFrame(coeffs, index=prices.iloc[periods[i]-periods[i]])

    df.columns = ['a0', 'b1', 'w']

    df = df.fillna(method='bfill')

    dict[periods[i]] = df

  results.coeffs = dict

  return results

def wadl(prices, periods):
  """
  :param: prices dataframe of OHLC
  :param: preiods (List) periods for which to calculate the functions (3,5,4....)
  """
  results = holder()
  dictW = {}

  for i in range(0, len(periods)):
    WAD = []

    for j in range(periods[i], len(prices)-periods[i]):
      TRH = np.array([prices.high.iloc[j]],prices.close.iloc[j-1]).max()
      TRL = np.array([prices.low.iloc[j]],prices.close.iloc[j-1]).min()

      if prices.close.iloc[j] > prices.close.iloc[j-1]:
        PM = prices.close.iloc[j] - TRL
      elif prices.close.iloc[j] < prices.close.iloc[j-1]:
        PM = prices.close.iloc[j] - TRH
      elif prices.close.iloc[j] == prices.close.iloc[j-1]:
        PM = 0
      else:
        print("Unknown error occured. PM cannot be calculated")

      AD = PM * prices.volume.iloc[j]

      WAD = np.append(WAD,AD)
  
    WAD = WAD.cumsum()

    WAD = pd.DataFrame(WAD, index=prices.iloc[periods[i]:-periods[i]].index)

    WAD.columns = ['close']

    dictW[periods[i]] = WAD

  results.wadl = dictW

  return results

#Timeframe resampler
def OHLCresample(DataFrame, TimeFrame, colums='ask'):

  """
  :param: DataFrame: data we want to resample
  :param: Timeframe: timeframe with which to resample
  :param: column: column we are resampling (bid or ask)
  :return: resampled dict of data for the given timeframe
  """
  try:
    grouped = DataFrame.groupby('Symbol')
  except:
    grouped = DataFrame

  if np.any(DataFrame.columns == 'Ask'):
    if column == 'ask':
      ask = grouped['Ask'].resample(TimeFrame).ohlc()
      askVol = gouped['volume'].resample(TimeFrame).count()
      resampled = pd.DataFrame(ask)
      resampled['volume'] = askVol
      resampled = resampled.dropna()
      return resampled
    elif column =='Bid':
      bid = grouped['Bid'].resample(TimeFrame).ohlc()
      bidVol = gouped['volume'].resample(TimeFrame).count()
      resampled = pd.DataFrame(bid)
      resampled['volume'] = bidVol
      resampled = resampled.dropna()
      return resampled
    else:
      raise ValueError('column must be either as or bid')
  elif np.any(DataFrame.columns == 'close'):
    open = grouped['open'].resample(TimeFrame).ohlc()
    close = grouped['close'].resample(TimeFrame).ohlc()
    high = grouped['high'].resample(TimeFrame).ohlc()
    low = grouped['low'].resample(TimeFrame).ohlc()
    askVol = grouped['volume'].resample(TimeFrame).count()

    resampled = pd.DataFrame(open)
    resampled['close'] = close
    resampled['high'] = high
    resampled['low'] = low

    resampled = resampled.dropna()

    return resampled

##momentum function
def momentum(prices, periods):
  """
  :param: prices: Dataframe of ohlc data
  :param: periods: list of periods to calculate function value
  :return: momentum indicator
  """

  results = holder()
  open = {}
  close = {}

  for i in range(0, len(periods)):
    open[periods[i]] = pd.DataFrame(prices.open.iloc[periods[i]:]-prices.open.iloc[:-periods[i]].values,
      index=prices.iloc[periods[i]:].index)

    close[periods[i]] = pd.DataFrame(prices.close.iloc[periods[i]:]-prices.close.iloc[:-periods[i]].values,
      index=prices.iloc[periods[i]:].index)

    open[periods[i]].columns = ['open']
    close[periods[i]].columns = ['close']
  results.open = open
  results.close = close

  return results

##stochastic oscillator function
def stochastic(prices, periods):
  """
  :param: prices: OHLC dataframe
  :param:periods: periods to calculate function value
  :return: oscillator function values
  """
  results = holder()
  close = {}

  for i in range(0, len(periods)):
    ks = []
    for j in range(periods[i],len(prices)-periods[i]):
      C = prices.close.iloc[j+1]
      H = prices.high.iloc[j-periods[i]:j].max()
      L = prices.low.iloc[j-periods[i]:j].min()

      if H == L:
        K = 0
      else:
        K = 100*(C-L)/(H-L)
      ks = np.append(ks, K)

    df = pd.DataFrame(ks, index=prices.iloc[periods[i]+1:-periods[i]+1].index)
    df.columns = ['K']
    df['D'] = df.K.rolling(3).mean()
    df = df.dropna()

    close[periods[i]] = df
  
  results.close = close

  return results

## Williams %R oscillator function
def williams(prices, periods):
  """
  :param: prices: OHLC price data
  :param: periods: list of periods to calculate function values
  :return: value of williams oscillator function
  """
  results = holder()
  close = {}

  for i in range(0, len(periods)):
    Rs = []
    for j in range(periods[i], len(prices)-periods[i]):

      C = prices.close.iloc[j+1]
      H = prices.high.iloc[j-periods[i]:j].max()
      L = prices.low.iloc[j-periods[i]:j].min()

      if H == L:
        R = 0
      else:
        R = -100 * (H-C)/(H-L)

      Rs = np.append(Rs,R)

    df = pd.DataFrame(Rs, index=prices.iloc[periods[i]+1:-periods[i]+1].index)
    df.columns = ['R']
    df.dropna()
    close[periods[i]] = df

  results.close = close

  return results

#PROC function (price rate of change)
def proc(prices, periods):
  """
  :param: prices: DataFrame containing prices
  :param: periods: list of periods to calculate PROC
  :return: PROC for indicated periods
  """
  results = holder()
  proc = {}

  for i in range(0, len(periods)):
    proc[periods[i]] = pd.DataFrame((prices.close.iloc[periods[i]:]-prices.close.iloc[:-periods[i]].values)\
      /prices.close.iloc[:-periods[i]].values)
    proc[periods[i]].columns = ['close']

  results.proc = proc

  return results

#Accumulation distribution oscillator function
def adosc(prices, periods):
  """
  :param: prices: OHLC DataFrame
  :param: periods: list of periods to compute indicator
  :return: indicator values for indicated periods
  """
  results = holder()
  accdist = {}

  for i in range(0, len(periods)):
    AD = []

    for j in range(periods[i], len(prices)-periods[i]):
      C = prices.close.iloc[j+1]
      H = prices.high.iloc[j-periods[i]:j].max()
      L = prices.low.iloc[j-periods[i]:j].min()
      V = prices.volume.iloc[j+1]

      if H == L:
        CLV = 0
      else:
        CLV = ((C-L) - (H-C))/(H-L)
      AD = np.append(AD, CLV * V)
    
    AD = AD.cumsum()
    AD = pd.DataFrame(AD, index=prices.iloc[periods[i]+1:-periods[i]+1].index)
    AD.columns = ['AD']
    accdist[periods[i]] = AD

  results.AD = accdist

  return results

#MACD (moving average convergence divergence)
def macd(prices, periods):
  """
  :param: prices: OHLC DataFrame of prices
  :param: periods: 1X2 array containing values for the EMAs
  :return: MACD for given periods
  """

  results = holder()

  EMA1 = prices.close.ewm(span=periods[0]).mean()
  EMA2 = prices.close.ewm(span=periods[1]).mean()

  MACD = pd.DataFrame(EMA1 - EMA2)
  MACD.columns = ['L']

  sigMACD = MACD.rolling(3).mean()
  sigMACD.columns = ['SL']

  results.line = MACD
  results.signal = sigMACD

  return results

# CCI (commodity CHannel Index) function
def cci(prices, periods):
  """
  :param: prices: OHLC DataFrame of prices
  :param: periods: periods for which to compute the data
  :return: CCI for given periods
  """
  results = holder()
  CCI = {}

  for i in range(0, len(periods)):
    MA = prices.close.rolling(periods[i]).mean()
    std = prices.close.rolling(periods[i]).std()

    D = (prices.close - MA)/std

    CCI[periods[i]] = pd.DataFrame((prices.close-MA)/(0.015*D))
    CCI[periods[i]].columns = ['close']
  
  results.cci = CCI

  return results